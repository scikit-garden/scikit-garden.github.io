{
    "docs": [
        {
            "location": "/",
            "text": "Scikit-garden\n\n\nScikit-garden or skgarden (pronounced as skarden) is a garden for scikit-learn compatible trees.\n\n\nInstallation\n\n\nDependencies\n\n\nscikit-garden depends on NumPy, SciPy, scikit-learn and Cython. So make sure these dependencies are installed using pip\n\n\npip3 install numpy scipy scikit-learn cython\n\n\n\n\nAfter that scikit-garden can be installed like any other package.\n\n\ngit clone https://github.com/scikit-garden/scikit-garden\ncd scikit-garden\npython3 setup.py install\n\n\n\n\nand then you can do\n\n\n>>> import skgarden\n\n\n\n\nfrom anywhere outside the root directory.\n\n\nAvailable models.",
            "title": "Home"
        },
        {
            "location": "/#scikit-garden",
            "text": "Scikit-garden or skgarden (pronounced as skarden) is a garden for scikit-learn compatible trees.",
            "title": "Scikit-garden"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#dependencies",
            "text": "scikit-garden depends on NumPy, SciPy, scikit-learn and Cython. So make sure these dependencies are installed using pip  pip3 install numpy scipy scikit-learn cython  After that scikit-garden can be installed like any other package.  git clone https://github.com/scikit-garden/scikit-garden\ncd scikit-garden\npython3 setup.py install  and then you can do  >>> import skgarden  from anywhere outside the root directory.",
            "title": "Dependencies"
        },
        {
            "location": "/#available-models",
            "text": "",
            "title": "Available models."
        },
        {
            "location": "/api/",
            "text": "API documentation of skgarden\n\n\nTable of contents\n\n\nskgarden.mondrian\n\n\n\n\nskgarden.mondrian.MondrianForestRegressor\n\n\nskgarden.mondrian.MondrianTreeRegressor\n\n\n\n\nskgarden.quantile\n\n\n\n\nskgarden.quantile.DecisionTreeQuantileRegressor\n\n\nskgarden.quantile.ExtraTreeQuantileRegressor\n\n\nskgarden.quantile.ExtraTreesQuantileRegressor\n\n\nskgarden.quantile.RandomForestQuantileRegressor\n\n\n\n\nskgarden.mondrian\n\n\nskgarden.mondrian.MondrianForestRegressor\n\n\nA MondrianForestRegressor is an ensemble of MondrianTrees.\n\n\nThe variance in predictions is reduced by averaging the predictions\nfrom all trees.\n\n\nParameters\n\n\n\n\n\n\nn_estimators\n (integer, optional (default=10))\n\n\nThe number of trees in the forest.\n\n\n\n\n\n\nmax_depth\n (integer, optional (default=None))\n\n\nThe depth to which each tree is grown. If None, the tree is either\ngrown to full depth or is constrained by \nmin_samples_split\n.\n\n\n\n\n\n\nmin_samples_split\n (integer, optional (default=2))\n\n\nStop growing the tree if all the nodes have lesser than\n\nmin_samples_split\n number of samples.\n\n\n\n\n\n\nbootstrap\n (boolean, optional (default=False))\n\n\nIf bootstrap is set to False, then all trees are trained on the\nentire training dataset. Else, each tree is fit on n_samples\ndrawn with replacement from the training dataset.\n\n\n\n\n\n\nrandom_state\n (int, RandomState instance or None, optional (default=None))\n\n\nIf int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby \nnp.random\n.\n\n\n\n\n\n\nMethods\n\n\nMondrianForestRegressor.fit(X, y)\n\n\nBuilds a forest of trees from the training set (X, y).\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like or sparse matrix of shape = [n_samples, n_features])\n\n\nThe training input samples. Internally, its dtype will be converted to\n\ndtype=np.float32\n. If a sparse matrix is provided, it will be\nconverted into a sparse \ncsc_matrix\n.\n\n\n\n\n\n\ny\n (array-like, shape = [n_samples] or [n_samples, n_outputs])\n\n\nThe target values (class labels in classification, real numbers in\nregression).\n\n\n\n\n\n\nsample_weight\n (array-like, shape = [n_samples] or None)\n\n\nSample weights. If None, then samples are equally weighted. Splits\nthat would create child nodes with net zero or negative weight are\nignored while searching for a split in each node. In the case of\nclassification, splits are also ignored if they would result in any\nsingle class carrying a negative weight in either child node.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\nself\n (object)\n\n\nReturns self.\n\n\n\n\n\n\nMondrianForestRegressor.predict(X, return_std=False)\n\n\nReturns the predicted mean and std.\n\n\nThe prediction is a GMM drawn from\n\\sum_{i=1}^T w_i N(m_i, \\sigma_i) where w_i = 1 / T.\n\n\nThe mean E[Y | X] reduces to 1 / T * \\sum_{i=1}^T m_i\n\n\nThe variance Var[Y | X] is given by\n    = E[Y\n2 | X] - E[Y | X]\n2\n    = (1 / T) * \\sum_{i=1}^T E[Y\n2_i| X] - E[Y| X]\n2\n    = (1 / T) * \\sum_{i=1}^T (Var[Y_i | X] + E[Y_i | X]\n2) - E[Y| X]\n2\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like, shape = (n_samples, n_features))\n\n\nInput samples.\n\n\n\n\n\n\nreturn_std\n (boolean, default (False))\n\n\nWhether or not to return the standard deviation.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\ny\n (array-like, shape = (n_samples,))\n\n\nPredictions at X.\n\n\n\n\n\n\nstd\n (array-like, shape = (n_samples,))\n\n\nStandard deviation at X.\n\n\n\n\n\n\nMondrianForestRegressor.weighted_decision_path(X)\n\n\nReturns the weighted decision path in the forest.\n\n\nEach non-zero value in the decision path determines the\nweight of that particular node while making predictions.\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like, shape = (n_samples, n_features))\n\n\nInput.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\ndecision_path\n (sparse csr matrix, shape = (n_samples, n_total_nodes))\n\n\nReturn a node indicator matrix where non zero elements\nindicate the weight of that particular node in making predictions.\n\n\n\n\n\n\nest_inds\n (array-like, shape = (n_estimators + 1,))\n\n\nweighted_decision_path[:, est_inds[i]: est_inds[i + 1]]\nprovides the weighted_decision_path of estimator i\n\n\n\n\n\n\nProperties\n\n\nskgarden.mondrian.MondrianTreeRegressor\n\n\nA Mondrian tree regressor.\n\n\nThe splits in a mondrian tree regressor differ from the standard regression\ntree in the following ways.\n\n\nAt fit time:\n    - Splits are done independently of the labels.\n    - The candidate feature is drawn with a probability proportional to the\n      feature range.\n    - The candidate threshold is drawn from a uniform distribution\n      with the bounds equal to the bounds of the candidate feature.\n    - The time of split is also stored which is proportional to the\n      inverse of the size of the bounding-box.\n\n\nAt prediction time:\n    - Every node in the path from the root to the leaf is given a weight\n      while making predictions.\n    - At each node, the probability of an unseen sample splitting from that\n      node is calculated. The farther the sample is away from the bounding\n      box, the more probable that it will split away.\n    - For every node, the probability that an unseen sample has not split\n      before reaching that node and the probability that it will split away\n      at that particular node are multiplied to give a weight.\n\n\nParameters\n\n\n\n\n\n\nmax_depth\n (int or None, optional (default=None))\n\n\nThe maximum depth of the tree. If None, then nodes are expanded until\nall leaves are pure or until all leaves contain less than\nmin_samples_split samples.\n\n\n\n\n\n\nmin_samples_split\n (int, float, optional (default=2))\n\n\nThe minimum number of samples required to split an internal node:\n\n\n\n\nIf int, then consider \nmin_samples_split\n as the minimum number.\n\n\nIf float, then \nmin_samples_split\n is a percentage and\n  \nceil(min_samples_split * n_samples)\n are the minimum\n  number of samples for each split.\n\n\n\n\n\n\n\n\nrandom_state\n (int, RandomState instance or None, optional (default=None))\n\n\nIf int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby \nnp.random\n.\n\n\n\n\n\n\nMethods\n\n\nMondrianTreeRegressor.apply(X, check_input=True)\n\n\nReturns the index of the leaf that each sample is predicted as.\n\n\n.. versionadded:: 0.17\n\n\nParameters\n\n\n\n\n\n\nX\n (array_like or sparse matrix, shape = [n_samples, n_features])\n\n\nThe input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsr_matrix\n.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\nX_leaves\n (array_like, shape = [n_samples,])\n\n\nFor each datapoint x in X, return the index of the leaf x\nends up in. Leaves are numbered within\n\n[0; self.tree_.node_count)\n, possibly with gaps in the\nnumbering.\n\n\n\n\n\n\nMondrianTreeRegressor.decision_path(X, check_input=True)\n\n\nReturn the decision path in the tree\n\n\n.. versionadded:: 0.18\n\n\nParameters\n\n\n\n\n\n\nX\n (array_like or sparse matrix, shape = [n_samples, n_features])\n\n\nThe input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsr_matrix\n.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\nindicator\n (sparse csr array, shape = [n_samples, n_nodes])\n\n\nReturn a node indicator matrix where non zero elements\nindicates that the samples goes through the nodes.\n\n\n\n\n\n\nMondrianTreeRegressor.fit(X, y, sample_weight=None, check_input=True, X_idx_sorted=None)\n\n\nBuild a mondrian tree regressor from the training set (X, y).\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like or sparse matrix, shape = [n_samples, n_features])\n\n\nThe training input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsc_matrix\n.\n\n\n\n\n\n\ny\n (array-like, shape = [n_samples] or [n_samples, n_outputs])\n\n\nThe target values (real numbers). Use \ndtype=np.float64\n and\n\norder='C'\n for maximum efficiency.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nX_idx_sorted\n (array-like, shape = [n_samples, n_features], optional)\n\n\nThe indexes of the sorted training input samples. If many tree\nare grown on the same dataset, this allows the ordering to be\ncached between trees. If None, the data will be sorted here.\nDon't use this parameter unless you know what to do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\nself\n (object)\n\n\nReturns self.\n\n\n\n\n\n\nMondrianTreeRegressor.predict(X, check_input=True, return_std=False)\n\n\nPredict class or regression value for X.\n\n\nFor a classification model, the predicted class for each sample in X is\nreturned. For a regression model, the predicted value based on X is\nreturned.\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like or sparse matrix of shape = [n_samples, n_features])\n\n\nThe input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsr_matrix\n.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nreturn_std\n (boolean, (default=True))\n\n\nWhether or not to return the standard deviation.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\ny\n (array of shape = [n_samples] or [n_samples, n_outputs])\n\n\nThe predicted classes, or the predict values.\n\n\n\n\n\n\nMondrianTreeRegressor.weighted_decision_path(X, check_input=True)\n\n\nReturns the weighted decision path in the tree.\n\n\nEach non-zero value in the decision path determines the weight\nof that particular node in making predictions.\n\n\nParameters\n\n\n\n\n\n\nX\n (array_like or sparse matrix, shape = [n_samples, n_features])\n\n\nThe input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsr_matrix\n.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\nindicator\n (sparse csr array, shape = [n_samples, n_nodes])\n\n\nReturn a node indicator matrix where non zero elements\nindicate the weight of that particular node in making predictions.\n\n\n\n\n\n\nProperties\n\n\nMondrianTreeRegressor.feature_importances_\n\n\nReturn the feature importances.\nThe importance of a feature is computed as the (normalized) total\nreduction of the criterion brought by that feature.\nIt is also known as the Gini importance.\n\nReturns\n\n\n\n\nfeature_importances_\n (array, shape = [n_features])\n\n\n\n\nskgarden.quantile\n\n\nskgarden.quantile.DecisionTreeQuantileRegressor\n\n\nA decision tree regressor that provides quantile estimates.\n\n\nParameters\n\n\n\n\n\n\ncriterion\n (string, optional (default=\"mse\"))\n\n\nThe function to measure the quality of a split. Supported criteria\nare \"mse\" for the mean squared error, which is equal to variance\nreduction as feature selection criterion, and \"mae\" for the mean\nabsolute error.\n.. versionadded:: 0.18\n   Mean Absolute Error (MAE) criterion.\n\n\n\n\n\n\nsplitter\n (string, optional (default=\"best\"))\n\n\nThe strategy used to choose the split at each node. Supported\nstrategies are \"best\" to choose the best split and \"random\" to choose\nthe best random split.\n\n\n\n\n\n\nmax_features\n (int, float, string or None, optional (default=None))\n\n\nThe number of features to consider when looking for the best split:\n- If int, then consider \nmax_features\n features at each split.\n- If float, then \nmax_features\n is a percentage and\n  \nint(max_features * n_features)\n features are considered at each\n  split.\n- If \"auto\", then \nmax_features=n_features\n.\n- If \"sqrt\", then \nmax_features=sqrt(n_features)\n.\n- If \"log2\", then \nmax_features=log2(n_features)\n.\n- If None, then \nmax_features=n_features\n.\nNote: the search for a split does not stop until at least one\nvalid partition of the node samples is found, even if it requires to\neffectively inspect more than \nmax_features\n features.\n\n\n\n\n\n\nmax_depth\n (int or None, optional (default=None))\n\n\nThe maximum depth of the tree. If None, then nodes are expanded until\nall leaves are pure or until all leaves contain less than\nmin_samples_split samples.\n\n\n\n\n\n\nmin_samples_split\n (int, float, optional (default=2))\n\n\nThe minimum number of samples required to split an internal node:\n- If int, then consider \nmin_samples_split\n as the minimum number.\n- If float, then \nmin_samples_split\n is a percentage and\n  \nceil(min_samples_split * n_samples)\n are the minimum\n  number of samples for each split.\n.. versionchanged:: 0.18\n   Added float values for percentages.\n\n\n\n\n\n\nmin_samples_leaf\n (int, float, optional (default=1))\n\n\nThe minimum number of samples required to be at a leaf node:\n- If int, then consider \nmin_samples_leaf\n as the minimum number.\n- If float, then \nmin_samples_leaf\n is a percentage and\n  \nceil(min_samples_leaf * n_samples)\n are the minimum\n  number of samples for each node.\n.. versionchanged:: 0.18\n   Added float values for percentages.\n\n\n\n\n\n\nmin_weight_fraction_leaf\n (float, optional (default=0.))\n\n\nThe minimum weighted fraction of the sum total of weights (of all\nthe input samples) required to be at a leaf node. Samples have\nequal weight when sample_weight is not provided.\n\n\n\n\n\n\nmax_leaf_nodes\n (int or None, optional (default=None))\n\n\nGrow a tree with \nmax_leaf_nodes\n in best-first fashion.\nBest nodes are defined as relative reduction in impurity.\nIf None then unlimited number of leaf nodes.\n\n\n\n\n\n\nrandom_state\n (int, RandomState instance or None, optional (default=None))\n\n\nIf int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby \nnp.random\n.\n\n\n\n\n\n\npresort\n (bool, optional (default=False))\n\n\nWhether to presort the data to speed up the finding of best splits in\nfitting. For the default settings of a decision tree on large\ndatasets, setting this to true may slow down the training process.\nWhen using either a smaller dataset or a restricted depth, this may\nspeed up the training.\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\nfeature_importances_\n (array of shape = [n_features])\n\n\nThe feature importances.\nThe higher, the more important the feature.\nThe importance of a feature is computed as the\n(normalized) total reduction of the criterion brought\nby that feature. It is also known as the Gini importance [4]_.\n\n\n\n\n\n\nmax_features_\n (int,)\n\n\nThe inferred value of max_features.\n\n\n\n\n\n\nn_features_\n (int)\n\n\nThe number of features when \nfit\n is performed.\n\n\n\n\n\n\nn_outputs_\n (int)\n\n\nThe number of outputs when \nfit\n is performed.\n\n\n\n\n\n\ntree_\n (Tree object)\n\n\nThe underlying Tree object.\n\n\n\n\n\n\ny_train_\n (array-like)\n\n\nTrain target values.\n\n\n\n\n\n\ny_train_leaves_\n (array-like.)\n\n\nCache the leaf nodes that each training sample falls into.\ny_train_leaves_[i] is the leaf that y_train[i] ends up at.\n\n\n\n\n\n\nMethods\n\n\nDecisionTreeQuantileRegressor.predict(X, quantile=None, check_input=False)\n\n\nPredict regression value for X.\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like or sparse matrix of shape = [n_samples, n_features])\n\n\nThe input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsr_matrix\n.\n\n\n\n\n\n\nquantile\n (int, optional)\n\n\nValue ranging from 0 to 100. By default, the mean is returned.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\ny\n (array of shape = [n_samples])\n\n\nIf quantile is set to None, then return E(Y | X). Else return\ny such that F(Y=y | x) = quantile.\n\n\n\n\n\n\nProperties\n\n\nskgarden.quantile.ExtraTreeQuantileRegressor\n\n\nAn extremely randomized tree regressor.\n\n\nExtra-trees differ from classic decision trees in the way they are built.\nWhen looking for the best split to separate the samples of a node into two\ngroups, random splits are drawn for each of the \nmax_features\n randomly\nselected features and the best split among those is chosen. When\n\nmax_features\n is set 1, this amounts to building a totally random\ndecision tree.\n\n\nWarning: Extra-trees should only be used within ensemble methods.\n\n\nRead more in the :ref:\nUser Guide <tree>\n.\n\n\nSee also\n\nExtraTreeClassifier, ExtraTreesClassifier, ExtraTreesRegressor\n\n\nReferences\n\n\n.. [1] P. Geurts, D. Ernst., and L. Wehenkel, \"Extremely randomized trees\",\n       Machine Learning, 63(1), 3-42, 2006.\n\n\nMethods\n\n\nExtraTreeQuantileRegressor.predict(X, quantile=None, check_input=False)\n\n\nPredict regression value for X.\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like or sparse matrix of shape = [n_samples, n_features])\n\n\nThe input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsr_matrix\n.\n\n\n\n\n\n\nquantile\n (int, optional)\n\n\nValue ranging from 0 to 100. By default, the mean is returned.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\ny\n (array of shape = [n_samples])\n\n\nIf quantile is set to None, then return E(Y | X). Else return\ny such that F(Y=y | x) = quantile.\n\n\n\n\n\n\nProperties\n\n\nskgarden.quantile.ExtraTreesQuantileRegressor\n\n\nAn extra-trees regressor that provides quantile estimates.\n\n\nThis class implements a meta estimator that fits a number of\nrandomized decision trees (a.k.a. extra-trees) on various sub-samples\nof the dataset and use averaging to improve the predictive accuracy\nand control over-fitting.\n\n\nParameters\n\n\n\n\n\n\nn_estimators\n (integer, optional (default=10))\n\n\nThe number of trees in the forest.\n\n\n\n\n\n\ncriterion\n (string, optional (default=\"mse\"))\n\n\nThe function to measure the quality of a split. Supported criteria\nare \"mse\" for the mean squared error, which is equal to variance\nreduction as feature selection criterion, and \"mae\" for the mean\nabsolute error.\n.. versionadded:: 0.18\n   Mean Absolute Error (MAE) criterion.\n\n\n\n\n\n\nmax_features\n (int, float, string or None, optional (default=\"auto\"))\n\n\nThe number of features to consider when looking for the best split:\n- If int, then consider \nmax_features\n features at each split.\n- If float, then \nmax_features\n is a percentage and\n  \nint(max_features * n_features)\n features are considered at each\n  split.\n- If \"auto\", then \nmax_features=n_features\n.\n- If \"sqrt\", then \nmax_features=sqrt(n_features)\n.\n- If \"log2\", then \nmax_features=log2(n_features)\n.\n- If None, then \nmax_features=n_features\n.\nNote: the search for a split does not stop until at least one\nvalid partition of the node samples is found, even if it requires to\neffectively inspect more than \nmax_features\n features.\n\n\n\n\n\n\nmax_depth\n (integer or None, optional (default=None))\n\n\nThe maximum depth of the tree. If None, then nodes are expanded until\nall leaves are pure or until all leaves contain less than\nmin_samples_split samples.\n\n\n\n\n\n\nmin_samples_split\n (int, float, optional (default=2))\n\n\nThe minimum number of samples required to split an internal node:\n- If int, then consider \nmin_samples_split\n as the minimum number.\n- If float, then \nmin_samples_split\n is a percentage and\n  \nceil(min_samples_split * n_samples)\n are the minimum\n  number of samples for each split.\n.. versionchanged:: 0.18\n   Added float values for percentages.\n\n\n\n\n\n\nmin_samples_leaf\n (int, float, optional (default=1))\n\n\nThe minimum number of samples required to be at a leaf node:\n- If int, then consider \nmin_samples_leaf\n as the minimum number.\n- If float, then \nmin_samples_leaf\n is a percentage and\n  \nceil(min_samples_leaf * n_samples)\n are the minimum\n  number of samples for each node.\n.. versionchanged:: 0.18\n   Added float values for percentages.\n\n\n\n\n\n\nmin_weight_fraction_leaf\n (float, optional (default=0.))\n\n\nThe minimum weighted fraction of the sum total of weights (of all\nthe input samples) required to be at a leaf node. Samples have\nequal weight when sample_weight is not provided.\n\n\n\n\n\n\nmax_leaf_nodes\n (int or None, optional (default=None))\n\n\nGrow trees with \nmax_leaf_nodes\n in best-first fashion.\nBest nodes are defined as relative reduction in impurity.\nIf None then unlimited number of leaf nodes.\n\n\n\n\n\n\nbootstrap\n (boolean, optional (default=False))\n\n\nWhether bootstrap samples are used when building trees.\n\n\n\n\n\n\noob_score\n (bool, optional (default=False))\n\n\nWhether to use out-of-bag samples to estimate the R^2 on unseen data.\n\n\n\n\n\n\nn_jobs\n (integer, optional (default=1))\n\n\nThe number of jobs to run in parallel for both \nfit\n and \npredict\n.\nIf -1, then the number of jobs is set to the number of cores.\n\n\n\n\n\n\nrandom_state\n (int, RandomState instance or None, optional (default=None))\n\n\nIf int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby \nnp.random\n.\n\n\n\n\n\n\nverbose\n (int, optional (default=0))\n\n\nControls the verbosity of the tree building process.\n\n\n\n\n\n\nwarm_start\n (bool, optional (default=False))\n\n\nWhen set to \nTrue\n, reuse the solution of the previous call to fit\nand add more estimators to the ensemble, otherwise, just fit a whole\nnew forest.\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\nestimators_\n (list of ExtraTreeQuantileRegressor)\n\n\nThe collection of fitted sub-estimators.\n\n\n\n\n\n\nfeature_importances_\n (array of shape = [n_features])\n\n\nThe feature importances (the higher, the more important the feature).\n\n\n\n\n\n\nn_features_\n (int)\n\n\nThe number of features when \nfit\n is performed.\n\n\n\n\n\n\nn_outputs_\n (int)\n\n\nThe number of outputs when \nfit\n is performed.\n\n\n\n\n\n\noob_score_\n (float)\n\n\nScore of the training dataset obtained using an out-of-bag estimate.\n\n\n\n\n\n\noob_prediction_\n (array of shape = [n_samples])\n\n\nPrediction computed with out-of-bag estimate on the training set.\n\n\n\n\n\n\ny_train_\n (array-like, shape=(n_samples,))\n\n\nCache the target values at fit time.\n\n\n\n\n\n\ny_weights_\n (array-like, shape=(n_estimators, n_samples))\n\n\ny_weights_[i, j] is the weight given to sample \nj` while\nestimator\ni`` is fit. If bootstrap is set to True, this\nreduces to a 2-D array of ones.\n\n\n\n\n\n\ny_train_leaves_\n (array-like, shape=(n_estimators, n_samples))\n\n\ny_train_leaves_[i, j] provides the leaf node that y_train_[i]\nends up when estimator j is fit. If y_train_[i] is given\na weight of zero when estimator j is fit, then the value is -1.\n\n\n\n\n\n\nReferences\n\n.. [1] Nicolai Meinshausen, Quantile Regression Forests\n    http://www.jmlr.org/papers/volume7/meinshausen06a/meinshausen06a.pdf\n\n\nMethods\n\n\nExtraTreesQuantileRegressor.fit(X, y)\n\n\nBuild a forest from the training set (X, y).\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like or sparse matrix, shape = [n_samples, n_features])\n\n\nThe training input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsc_matrix\n.\n\n\n\n\n\n\ny\n (array-like, shape = [n_samples] or [n_samples, n_outputs])\n\n\nThe target values (class labels) as integers or strings.\n\n\n\n\n\n\nsample_weight\n (array-like, shape = [n_samples] or None)\n\n\nSample weights. If None, then samples are equally weighted. Splits\nthat would create child nodes with net zero or negative weight are\nignored while searching for a split in each node. Splits are also\nignored if they would result in any single class carrying a\nnegative weight in either child node.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nX_idx_sorted\n (array-like, shape = [n_samples, n_features], optional)\n\n\nThe indexes of the sorted training input samples. If many tree\nare grown on the same dataset, this allows the ordering to be\ncached between trees. If None, the data will be sorted here.\nDon't use this parameter unless you know what to do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\nself\n (object)\n\n\nReturns self.\n\n\n\n\n\n\nExtraTreesQuantileRegressor.predict(X, quantile=None)\n\n\nPredict regression value for X.\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like or sparse matrix of shape = [n_samples, n_features])\n\n\nThe input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsr_matrix\n.\n\n\n\n\n\n\nquantile\n (int, optional)\n\n\nValue ranging from 0 to 100. By default, the mean is returned.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\ny\n (array of shape = [n_samples])\n\n\nIf quantile is set to None, then return E(Y | X). Else return\ny such that F(Y=y | x) = quantile.\n\n\n\n\n\n\nProperties\n\n\nskgarden.quantile.RandomForestQuantileRegressor\n\n\nA random forest regressor that provides quantile estimates.\n\n\nA random forest is a meta estimator that fits a number of classifying\ndecision trees on various sub-samples of the dataset and use averaging\nto improve the predictive accuracy and control over-fitting.\nThe sub-sample size is always the same as the original\ninput sample size but the samples are drawn with replacement if\n\nbootstrap=True\n (default).\n\n\nParameters\n\n\n\n\n\n\nn_estimators\n (integer, optional (default=10))\n\n\nThe number of trees in the forest.\n\n\n\n\n\n\ncriterion\n (string, optional (default=\"mse\"))\n\n\nThe function to measure the quality of a split. Supported criteria\nare \"mse\" for the mean squared error, which is equal to variance\nreduction as feature selection criterion, and \"mae\" for the mean\nabsolute error.\n.. versionadded:: 0.18\n   Mean Absolute Error (MAE) criterion.\n\n\n\n\n\n\nmax_features\n (int, float, string or None, optional (default=\"auto\"))\n\n\nThe number of features to consider when looking for the best split:\n- If int, then consider \nmax_features\n features at each split.\n- If float, then \nmax_features\n is a percentage and\n  \nint(max_features * n_features)\n features are considered at each\n  split.\n- If \"auto\", then \nmax_features=n_features\n.\n- If \"sqrt\", then \nmax_features=sqrt(n_features)\n.\n- If \"log2\", then \nmax_features=log2(n_features)\n.\n- If None, then \nmax_features=n_features\n.\nNote: the search for a split does not stop until at least one\nvalid partition of the node samples is found, even if it requires to\neffectively inspect more than \nmax_features\n features.\n\n\n\n\n\n\nmax_depth\n (integer or None, optional (default=None))\n\n\nThe maximum depth of the tree. If None, then nodes are expanded until\nall leaves are pure or until all leaves contain less than\nmin_samples_split samples.\n\n\n\n\n\n\nmin_samples_split\n (int, float, optional (default=2))\n\n\nThe minimum number of samples required to split an internal node:\n- If int, then consider \nmin_samples_split\n as the minimum number.\n- If float, then \nmin_samples_split\n is a percentage and\n  \nceil(min_samples_split * n_samples)\n are the minimum\n  number of samples for each split.\n.. versionchanged:: 0.18\n   Added float values for percentages.\n\n\n\n\n\n\nmin_samples_leaf\n (int, float, optional (default=1))\n\n\nThe minimum number of samples required to be at a leaf node:\n- If int, then consider \nmin_samples_leaf\n as the minimum number.\n- If float, then \nmin_samples_leaf\n is a percentage and\n  \nceil(min_samples_leaf * n_samples)\n are the minimum\n  number of samples for each node.\n.. versionchanged:: 0.18\n   Added float values for percentages.\n\n\n\n\n\n\nmin_weight_fraction_leaf\n (float, optional (default=0.))\n\n\nThe minimum weighted fraction of the sum total of weights (of all\nthe input samples) required to be at a leaf node. Samples have\nequal weight when sample_weight is not provided.\n\n\n\n\n\n\nmax_leaf_nodes\n (int or None, optional (default=None))\n\n\nGrow trees with \nmax_leaf_nodes\n in best-first fashion.\nBest nodes are defined as relative reduction in impurity.\nIf None then unlimited number of leaf nodes.\n\n\n\n\n\n\nbootstrap\n (boolean, optional (default=True))\n\n\nWhether bootstrap samples are used when building trees.\n\n\n\n\n\n\noob_score\n (bool, optional (default=False))\n\n\nwhether to use out-of-bag samples to estimate\nthe R^2 on unseen data.\n\n\n\n\n\n\nn_jobs\n (integer, optional (default=1))\n\n\nThe number of jobs to run in parallel for both \nfit\n and \npredict\n.\nIf -1, then the number of jobs is set to the number of cores.\n\n\n\n\n\n\nrandom_state\n (int, RandomState instance or None, optional (default=None))\n\n\nIf int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby \nnp.random\n.\n\n\n\n\n\n\nverbose\n (int, optional (default=0))\n\n\nControls the verbosity of the tree building process.\n\n\n\n\n\n\nwarm_start\n (bool, optional (default=False))\n\n\nWhen set to \nTrue\n, reuse the solution of the previous call to fit\nand add more estimators to the ensemble, otherwise, just fit a whole\nnew forest.\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\nestimators_\n (list of DecisionTreeQuantileRegressor)\n\n\nThe collection of fitted sub-estimators.\n\n\n\n\n\n\nfeature_importances_\n (array of shape = [n_features])\n\n\nThe feature importances (the higher, the more important the feature).\n\n\n\n\n\n\nn_features_\n (int)\n\n\nThe number of features when \nfit\n is performed.\n\n\n\n\n\n\nn_outputs_\n (int)\n\n\nThe number of outputs when \nfit\n is performed.\n\n\n\n\n\n\noob_score_\n (float)\n\n\nScore of the training dataset obtained using an out-of-bag estimate.\n\n\n\n\n\n\noob_prediction_\n (array of shape = [n_samples])\n\n\nPrediction computed with out-of-bag estimate on the training set.\n\n\n\n\n\n\ny_train_\n (array-like, shape=(n_samples,))\n\n\nCache the target values at fit time.\n\n\n\n\n\n\ny_weights_\n (array-like, shape=(n_estimators, n_samples))\n\n\ny_weights_[i, j] is the weight given to sample \nj` while\nestimator\ni`` is fit. If bootstrap is set to True, this\nreduces to a 2-D array of ones.\n\n\n\n\n\n\ny_train_leaves_\n (array-like, shape=(n_estimators, n_samples))\n\n\ny_train_leaves_[i, j] provides the leaf node that y_train_[i]\nends up when estimator j is fit. If y_train_[i] is given\na weight of zero when estimator j is fit, then the value is -1.\n\n\n\n\n\n\nReferences\n\n.. [1] Nicolai Meinshausen, Quantile Regression Forests\n    http://www.jmlr.org/papers/volume7/meinshausen06a/meinshausen06a.pdf\n\n\nMethods\n\n\nRandomForestQuantileRegressor.fit(X, y)\n\n\nBuild a forest from the training set (X, y).\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like or sparse matrix, shape = [n_samples, n_features])\n\n\nThe training input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsc_matrix\n.\n\n\n\n\n\n\ny\n (array-like, shape = [n_samples] or [n_samples, n_outputs])\n\n\nThe target values (class labels) as integers or strings.\n\n\n\n\n\n\nsample_weight\n (array-like, shape = [n_samples] or None)\n\n\nSample weights. If None, then samples are equally weighted. Splits\nthat would create child nodes with net zero or negative weight are\nignored while searching for a split in each node. Splits are also\nignored if they would result in any single class carrying a\nnegative weight in either child node.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nX_idx_sorted\n (array-like, shape = [n_samples, n_features], optional)\n\n\nThe indexes of the sorted training input samples. If many tree\nare grown on the same dataset, this allows the ordering to be\ncached between trees. If None, the data will be sorted here.\nDon't use this parameter unless you know what to do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\nself\n (object)\n\n\nReturns self.\n\n\n\n\n\n\nRandomForestQuantileRegressor.predict(X, quantile=None)\n\n\nPredict regression value for X.\n\n\nParameters\n\n\n\n\n\n\nX\n (array-like or sparse matrix of shape = [n_samples, n_features])\n\n\nThe input samples. Internally, it will be converted to\n\ndtype=np.float32\n and if a sparse matrix is provided\nto a sparse \ncsr_matrix\n.\n\n\n\n\n\n\nquantile\n (int, optional)\n\n\nValue ranging from 0 to 100. By default, the mean is returned.\n\n\n\n\n\n\ncheck_input\n (boolean, (default=True))\n\n\nAllow to bypass several input checking.\nDon't use this parameter unless you know what you do.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\ny\n (array of shape = [n_samples])\n\n\nIf quantile is set to None, then return E(Y | X). Else return\ny such that F(Y=y | x) = quantile.\n\n\n\n\n\n\nProperties",
            "title": "API Reference"
        },
        {
            "location": "/api/#api-documentation-of-skgarden",
            "text": "",
            "title": "API documentation of skgarden"
        },
        {
            "location": "/api/#table-of-contents",
            "text": "",
            "title": "Table of contents"
        },
        {
            "location": "/api/#skgardenmondrian",
            "text": "skgarden.mondrian.MondrianForestRegressor  skgarden.mondrian.MondrianTreeRegressor",
            "title": "skgarden.mondrian"
        },
        {
            "location": "/api/#skgardenquantile",
            "text": "skgarden.quantile.DecisionTreeQuantileRegressor  skgarden.quantile.ExtraTreeQuantileRegressor  skgarden.quantile.ExtraTreesQuantileRegressor  skgarden.quantile.RandomForestQuantileRegressor",
            "title": "skgarden.quantile"
        },
        {
            "location": "/api/#skgardenmondrian_1",
            "text": "",
            "title": "skgarden.mondrian"
        },
        {
            "location": "/api/#skgardenmondrianmondrianforestregressor",
            "text": "A MondrianForestRegressor is an ensemble of MondrianTrees.  The variance in predictions is reduced by averaging the predictions\nfrom all trees.  Parameters    n_estimators  (integer, optional (default=10))  The number of trees in the forest.    max_depth  (integer, optional (default=None))  The depth to which each tree is grown. If None, the tree is either\ngrown to full depth or is constrained by  min_samples_split .    min_samples_split  (integer, optional (default=2))  Stop growing the tree if all the nodes have lesser than min_samples_split  number of samples.    bootstrap  (boolean, optional (default=False))  If bootstrap is set to False, then all trees are trained on the\nentire training dataset. Else, each tree is fit on n_samples\ndrawn with replacement from the training dataset.    random_state  (int, RandomState instance or None, optional (default=None))  If int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby  np.random .",
            "title": "skgarden.mondrian.MondrianForestRegressor"
        },
        {
            "location": "/api/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api/#mondrianforestregressorfitx-y",
            "text": "Builds a forest of trees from the training set (X, y).  Parameters    X  (array-like or sparse matrix of shape = [n_samples, n_features])  The training input samples. Internally, its dtype will be converted to dtype=np.float32 . If a sparse matrix is provided, it will be\nconverted into a sparse  csc_matrix .    y  (array-like, shape = [n_samples] or [n_samples, n_outputs])  The target values (class labels in classification, real numbers in\nregression).    sample_weight  (array-like, shape = [n_samples] or None)  Sample weights. If None, then samples are equally weighted. Splits\nthat would create child nodes with net zero or negative weight are\nignored while searching for a split in each node. In the case of\nclassification, splits are also ignored if they would result in any\nsingle class carrying a negative weight in either child node.    Returns    self  (object)  Returns self.",
            "title": "MondrianForestRegressor.fit(X, y)"
        },
        {
            "location": "/api/#mondrianforestregressorpredictx-return_stdfalse",
            "text": "Returns the predicted mean and std.  The prediction is a GMM drawn from\n\\sum_{i=1}^T w_i N(m_i, \\sigma_i) where w_i = 1 / T.  The mean E[Y | X] reduces to 1 / T * \\sum_{i=1}^T m_i  The variance Var[Y | X] is given by\n    = E[Y 2 | X] - E[Y | X] 2\n    = (1 / T) * \\sum_{i=1}^T E[Y 2_i| X] - E[Y| X] 2\n    = (1 / T) * \\sum_{i=1}^T (Var[Y_i | X] + E[Y_i | X] 2) - E[Y| X] 2  Parameters    X  (array-like, shape = (n_samples, n_features))  Input samples.    return_std  (boolean, default (False))  Whether or not to return the standard deviation.    Returns    y  (array-like, shape = (n_samples,))  Predictions at X.    std  (array-like, shape = (n_samples,))  Standard deviation at X.",
            "title": "MondrianForestRegressor.predict(X, return_std=False)"
        },
        {
            "location": "/api/#mondrianforestregressorweighted_decision_pathx",
            "text": "Returns the weighted decision path in the forest.  Each non-zero value in the decision path determines the\nweight of that particular node while making predictions.  Parameters    X  (array-like, shape = (n_samples, n_features))  Input.    Returns    decision_path  (sparse csr matrix, shape = (n_samples, n_total_nodes))  Return a node indicator matrix where non zero elements\nindicate the weight of that particular node in making predictions.    est_inds  (array-like, shape = (n_estimators + 1,))  weighted_decision_path[:, est_inds[i]: est_inds[i + 1]]\nprovides the weighted_decision_path of estimator i",
            "title": "MondrianForestRegressor.weighted_decision_path(X)"
        },
        {
            "location": "/api/#properties",
            "text": "",
            "title": "Properties"
        },
        {
            "location": "/api/#skgardenmondrianmondriantreeregressor",
            "text": "A Mondrian tree regressor.  The splits in a mondrian tree regressor differ from the standard regression\ntree in the following ways.  At fit time:\n    - Splits are done independently of the labels.\n    - The candidate feature is drawn with a probability proportional to the\n      feature range.\n    - The candidate threshold is drawn from a uniform distribution\n      with the bounds equal to the bounds of the candidate feature.\n    - The time of split is also stored which is proportional to the\n      inverse of the size of the bounding-box.  At prediction time:\n    - Every node in the path from the root to the leaf is given a weight\n      while making predictions.\n    - At each node, the probability of an unseen sample splitting from that\n      node is calculated. The farther the sample is away from the bounding\n      box, the more probable that it will split away.\n    - For every node, the probability that an unseen sample has not split\n      before reaching that node and the probability that it will split away\n      at that particular node are multiplied to give a weight.  Parameters    max_depth  (int or None, optional (default=None))  The maximum depth of the tree. If None, then nodes are expanded until\nall leaves are pure or until all leaves contain less than\nmin_samples_split samples.    min_samples_split  (int, float, optional (default=2))  The minimum number of samples required to split an internal node:   If int, then consider  min_samples_split  as the minimum number.  If float, then  min_samples_split  is a percentage and\n   ceil(min_samples_split * n_samples)  are the minimum\n  number of samples for each split.     random_state  (int, RandomState instance or None, optional (default=None))  If int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby  np.random .",
            "title": "skgarden.mondrian.MondrianTreeRegressor"
        },
        {
            "location": "/api/#methods_1",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api/#mondriantreeregressorapplyx-check_inputtrue",
            "text": "Returns the index of the leaf that each sample is predicted as.  .. versionadded:: 0.17  Parameters    X  (array_like or sparse matrix, shape = [n_samples, n_features])  The input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csr_matrix .    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    Returns    X_leaves  (array_like, shape = [n_samples,])  For each datapoint x in X, return the index of the leaf x\nends up in. Leaves are numbered within [0; self.tree_.node_count) , possibly with gaps in the\nnumbering.",
            "title": "MondrianTreeRegressor.apply(X, check_input=True)"
        },
        {
            "location": "/api/#mondriantreeregressordecision_pathx-check_inputtrue",
            "text": "Return the decision path in the tree  .. versionadded:: 0.18  Parameters    X  (array_like or sparse matrix, shape = [n_samples, n_features])  The input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csr_matrix .    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    Returns    indicator  (sparse csr array, shape = [n_samples, n_nodes])  Return a node indicator matrix where non zero elements\nindicates that the samples goes through the nodes.",
            "title": "MondrianTreeRegressor.decision_path(X, check_input=True)"
        },
        {
            "location": "/api/#mondriantreeregressorfitx-y-sample_weightnone-check_inputtrue-x_idx_sortednone",
            "text": "Build a mondrian tree regressor from the training set (X, y).  Parameters    X  (array-like or sparse matrix, shape = [n_samples, n_features])  The training input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csc_matrix .    y  (array-like, shape = [n_samples] or [n_samples, n_outputs])  The target values (real numbers). Use  dtype=np.float64  and order='C'  for maximum efficiency.    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    X_idx_sorted  (array-like, shape = [n_samples, n_features], optional)  The indexes of the sorted training input samples. If many tree\nare grown on the same dataset, this allows the ordering to be\ncached between trees. If None, the data will be sorted here.\nDon't use this parameter unless you know what to do.    Returns    self  (object)  Returns self.",
            "title": "MondrianTreeRegressor.fit(X, y, sample_weight=None, check_input=True, X_idx_sorted=None)"
        },
        {
            "location": "/api/#mondriantreeregressorpredictx-check_inputtrue-return_stdfalse",
            "text": "Predict class or regression value for X.  For a classification model, the predicted class for each sample in X is\nreturned. For a regression model, the predicted value based on X is\nreturned.  Parameters    X  (array-like or sparse matrix of shape = [n_samples, n_features])  The input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csr_matrix .    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    return_std  (boolean, (default=True))  Whether or not to return the standard deviation.    Returns    y  (array of shape = [n_samples] or [n_samples, n_outputs])  The predicted classes, or the predict values.",
            "title": "MondrianTreeRegressor.predict(X, check_input=True, return_std=False)"
        },
        {
            "location": "/api/#mondriantreeregressorweighted_decision_pathx-check_inputtrue",
            "text": "Returns the weighted decision path in the tree.  Each non-zero value in the decision path determines the weight\nof that particular node in making predictions.  Parameters    X  (array_like or sparse matrix, shape = [n_samples, n_features])  The input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csr_matrix .    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    Returns    indicator  (sparse csr array, shape = [n_samples, n_nodes])  Return a node indicator matrix where non zero elements\nindicate the weight of that particular node in making predictions.",
            "title": "MondrianTreeRegressor.weighted_decision_path(X, check_input=True)"
        },
        {
            "location": "/api/#properties_1",
            "text": "",
            "title": "Properties"
        },
        {
            "location": "/api/#mondriantreeregressorfeature_importances_",
            "text": "Return the feature importances.\nThe importance of a feature is computed as the (normalized) total\nreduction of the criterion brought by that feature.\nIt is also known as the Gini importance. Returns   feature_importances_  (array, shape = [n_features])",
            "title": "MondrianTreeRegressor.feature_importances_"
        },
        {
            "location": "/api/#skgardenquantile_1",
            "text": "",
            "title": "skgarden.quantile"
        },
        {
            "location": "/api/#skgardenquantiledecisiontreequantileregressor",
            "text": "A decision tree regressor that provides quantile estimates.  Parameters    criterion  (string, optional (default=\"mse\"))  The function to measure the quality of a split. Supported criteria\nare \"mse\" for the mean squared error, which is equal to variance\nreduction as feature selection criterion, and \"mae\" for the mean\nabsolute error.\n.. versionadded:: 0.18\n   Mean Absolute Error (MAE) criterion.    splitter  (string, optional (default=\"best\"))  The strategy used to choose the split at each node. Supported\nstrategies are \"best\" to choose the best split and \"random\" to choose\nthe best random split.    max_features  (int, float, string or None, optional (default=None))  The number of features to consider when looking for the best split:\n- If int, then consider  max_features  features at each split.\n- If float, then  max_features  is a percentage and\n   int(max_features * n_features)  features are considered at each\n  split.\n- If \"auto\", then  max_features=n_features .\n- If \"sqrt\", then  max_features=sqrt(n_features) .\n- If \"log2\", then  max_features=log2(n_features) .\n- If None, then  max_features=n_features .\nNote: the search for a split does not stop until at least one\nvalid partition of the node samples is found, even if it requires to\neffectively inspect more than  max_features  features.    max_depth  (int or None, optional (default=None))  The maximum depth of the tree. If None, then nodes are expanded until\nall leaves are pure or until all leaves contain less than\nmin_samples_split samples.    min_samples_split  (int, float, optional (default=2))  The minimum number of samples required to split an internal node:\n- If int, then consider  min_samples_split  as the minimum number.\n- If float, then  min_samples_split  is a percentage and\n   ceil(min_samples_split * n_samples)  are the minimum\n  number of samples for each split.\n.. versionchanged:: 0.18\n   Added float values for percentages.    min_samples_leaf  (int, float, optional (default=1))  The minimum number of samples required to be at a leaf node:\n- If int, then consider  min_samples_leaf  as the minimum number.\n- If float, then  min_samples_leaf  is a percentage and\n   ceil(min_samples_leaf * n_samples)  are the minimum\n  number of samples for each node.\n.. versionchanged:: 0.18\n   Added float values for percentages.    min_weight_fraction_leaf  (float, optional (default=0.))  The minimum weighted fraction of the sum total of weights (of all\nthe input samples) required to be at a leaf node. Samples have\nequal weight when sample_weight is not provided.    max_leaf_nodes  (int or None, optional (default=None))  Grow a tree with  max_leaf_nodes  in best-first fashion.\nBest nodes are defined as relative reduction in impurity.\nIf None then unlimited number of leaf nodes.    random_state  (int, RandomState instance or None, optional (default=None))  If int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby  np.random .    presort  (bool, optional (default=False))  Whether to presort the data to speed up the finding of best splits in\nfitting. For the default settings of a decision tree on large\ndatasets, setting this to true may slow down the training process.\nWhen using either a smaller dataset or a restricted depth, this may\nspeed up the training.    Attributes    feature_importances_  (array of shape = [n_features])  The feature importances.\nThe higher, the more important the feature.\nThe importance of a feature is computed as the\n(normalized) total reduction of the criterion brought\nby that feature. It is also known as the Gini importance [4]_.    max_features_  (int,)  The inferred value of max_features.    n_features_  (int)  The number of features when  fit  is performed.    n_outputs_  (int)  The number of outputs when  fit  is performed.    tree_  (Tree object)  The underlying Tree object.    y_train_  (array-like)  Train target values.    y_train_leaves_  (array-like.)  Cache the leaf nodes that each training sample falls into.\ny_train_leaves_[i] is the leaf that y_train[i] ends up at.",
            "title": "skgarden.quantile.DecisionTreeQuantileRegressor"
        },
        {
            "location": "/api/#methods_2",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api/#decisiontreequantileregressorpredictx-quantilenone-check_inputfalse",
            "text": "Predict regression value for X.  Parameters    X  (array-like or sparse matrix of shape = [n_samples, n_features])  The input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csr_matrix .    quantile  (int, optional)  Value ranging from 0 to 100. By default, the mean is returned.    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    Returns    y  (array of shape = [n_samples])  If quantile is set to None, then return E(Y | X). Else return\ny such that F(Y=y | x) = quantile.",
            "title": "DecisionTreeQuantileRegressor.predict(X, quantile=None, check_input=False)"
        },
        {
            "location": "/api/#properties_2",
            "text": "",
            "title": "Properties"
        },
        {
            "location": "/api/#skgardenquantileextratreequantileregressor",
            "text": "An extremely randomized tree regressor.  Extra-trees differ from classic decision trees in the way they are built.\nWhen looking for the best split to separate the samples of a node into two\ngroups, random splits are drawn for each of the  max_features  randomly\nselected features and the best split among those is chosen. When max_features  is set 1, this amounts to building a totally random\ndecision tree.  Warning: Extra-trees should only be used within ensemble methods.  Read more in the :ref: User Guide <tree> .  See also \nExtraTreeClassifier, ExtraTreesClassifier, ExtraTreesRegressor  References  .. [1] P. Geurts, D. Ernst., and L. Wehenkel, \"Extremely randomized trees\",\n       Machine Learning, 63(1), 3-42, 2006.",
            "title": "skgarden.quantile.ExtraTreeQuantileRegressor"
        },
        {
            "location": "/api/#methods_3",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api/#extratreequantileregressorpredictx-quantilenone-check_inputfalse",
            "text": "Predict regression value for X.  Parameters    X  (array-like or sparse matrix of shape = [n_samples, n_features])  The input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csr_matrix .    quantile  (int, optional)  Value ranging from 0 to 100. By default, the mean is returned.    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    Returns    y  (array of shape = [n_samples])  If quantile is set to None, then return E(Y | X). Else return\ny such that F(Y=y | x) = quantile.",
            "title": "ExtraTreeQuantileRegressor.predict(X, quantile=None, check_input=False)"
        },
        {
            "location": "/api/#properties_3",
            "text": "",
            "title": "Properties"
        },
        {
            "location": "/api/#skgardenquantileextratreesquantileregressor",
            "text": "An extra-trees regressor that provides quantile estimates.  This class implements a meta estimator that fits a number of\nrandomized decision trees (a.k.a. extra-trees) on various sub-samples\nof the dataset and use averaging to improve the predictive accuracy\nand control over-fitting.  Parameters    n_estimators  (integer, optional (default=10))  The number of trees in the forest.    criterion  (string, optional (default=\"mse\"))  The function to measure the quality of a split. Supported criteria\nare \"mse\" for the mean squared error, which is equal to variance\nreduction as feature selection criterion, and \"mae\" for the mean\nabsolute error.\n.. versionadded:: 0.18\n   Mean Absolute Error (MAE) criterion.    max_features  (int, float, string or None, optional (default=\"auto\"))  The number of features to consider when looking for the best split:\n- If int, then consider  max_features  features at each split.\n- If float, then  max_features  is a percentage and\n   int(max_features * n_features)  features are considered at each\n  split.\n- If \"auto\", then  max_features=n_features .\n- If \"sqrt\", then  max_features=sqrt(n_features) .\n- If \"log2\", then  max_features=log2(n_features) .\n- If None, then  max_features=n_features .\nNote: the search for a split does not stop until at least one\nvalid partition of the node samples is found, even if it requires to\neffectively inspect more than  max_features  features.    max_depth  (integer or None, optional (default=None))  The maximum depth of the tree. If None, then nodes are expanded until\nall leaves are pure or until all leaves contain less than\nmin_samples_split samples.    min_samples_split  (int, float, optional (default=2))  The minimum number of samples required to split an internal node:\n- If int, then consider  min_samples_split  as the minimum number.\n- If float, then  min_samples_split  is a percentage and\n   ceil(min_samples_split * n_samples)  are the minimum\n  number of samples for each split.\n.. versionchanged:: 0.18\n   Added float values for percentages.    min_samples_leaf  (int, float, optional (default=1))  The minimum number of samples required to be at a leaf node:\n- If int, then consider  min_samples_leaf  as the minimum number.\n- If float, then  min_samples_leaf  is a percentage and\n   ceil(min_samples_leaf * n_samples)  are the minimum\n  number of samples for each node.\n.. versionchanged:: 0.18\n   Added float values for percentages.    min_weight_fraction_leaf  (float, optional (default=0.))  The minimum weighted fraction of the sum total of weights (of all\nthe input samples) required to be at a leaf node. Samples have\nequal weight when sample_weight is not provided.    max_leaf_nodes  (int or None, optional (default=None))  Grow trees with  max_leaf_nodes  in best-first fashion.\nBest nodes are defined as relative reduction in impurity.\nIf None then unlimited number of leaf nodes.    bootstrap  (boolean, optional (default=False))  Whether bootstrap samples are used when building trees.    oob_score  (bool, optional (default=False))  Whether to use out-of-bag samples to estimate the R^2 on unseen data.    n_jobs  (integer, optional (default=1))  The number of jobs to run in parallel for both  fit  and  predict .\nIf -1, then the number of jobs is set to the number of cores.    random_state  (int, RandomState instance or None, optional (default=None))  If int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby  np.random .    verbose  (int, optional (default=0))  Controls the verbosity of the tree building process.    warm_start  (bool, optional (default=False))  When set to  True , reuse the solution of the previous call to fit\nand add more estimators to the ensemble, otherwise, just fit a whole\nnew forest.    Attributes    estimators_  (list of ExtraTreeQuantileRegressor)  The collection of fitted sub-estimators.    feature_importances_  (array of shape = [n_features])  The feature importances (the higher, the more important the feature).    n_features_  (int)  The number of features when  fit  is performed.    n_outputs_  (int)  The number of outputs when  fit  is performed.    oob_score_  (float)  Score of the training dataset obtained using an out-of-bag estimate.    oob_prediction_  (array of shape = [n_samples])  Prediction computed with out-of-bag estimate on the training set.    y_train_  (array-like, shape=(n_samples,))  Cache the target values at fit time.    y_weights_  (array-like, shape=(n_estimators, n_samples))  y_weights_[i, j] is the weight given to sample  j` while\nestimator i`` is fit. If bootstrap is set to True, this\nreduces to a 2-D array of ones.    y_train_leaves_  (array-like, shape=(n_estimators, n_samples))  y_train_leaves_[i, j] provides the leaf node that y_train_[i]\nends up when estimator j is fit. If y_train_[i] is given\na weight of zero when estimator j is fit, then the value is -1.    References \n.. [1] Nicolai Meinshausen, Quantile Regression Forests\n    http://www.jmlr.org/papers/volume7/meinshausen06a/meinshausen06a.pdf",
            "title": "skgarden.quantile.ExtraTreesQuantileRegressor"
        },
        {
            "location": "/api/#methods_4",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api/#extratreesquantileregressorfitx-y",
            "text": "Build a forest from the training set (X, y).  Parameters    X  (array-like or sparse matrix, shape = [n_samples, n_features])  The training input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csc_matrix .    y  (array-like, shape = [n_samples] or [n_samples, n_outputs])  The target values (class labels) as integers or strings.    sample_weight  (array-like, shape = [n_samples] or None)  Sample weights. If None, then samples are equally weighted. Splits\nthat would create child nodes with net zero or negative weight are\nignored while searching for a split in each node. Splits are also\nignored if they would result in any single class carrying a\nnegative weight in either child node.    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    X_idx_sorted  (array-like, shape = [n_samples, n_features], optional)  The indexes of the sorted training input samples. If many tree\nare grown on the same dataset, this allows the ordering to be\ncached between trees. If None, the data will be sorted here.\nDon't use this parameter unless you know what to do.    Returns    self  (object)  Returns self.",
            "title": "ExtraTreesQuantileRegressor.fit(X, y)"
        },
        {
            "location": "/api/#extratreesquantileregressorpredictx-quantilenone",
            "text": "Predict regression value for X.  Parameters    X  (array-like or sparse matrix of shape = [n_samples, n_features])  The input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csr_matrix .    quantile  (int, optional)  Value ranging from 0 to 100. By default, the mean is returned.    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    Returns    y  (array of shape = [n_samples])  If quantile is set to None, then return E(Y | X). Else return\ny such that F(Y=y | x) = quantile.",
            "title": "ExtraTreesQuantileRegressor.predict(X, quantile=None)"
        },
        {
            "location": "/api/#properties_4",
            "text": "",
            "title": "Properties"
        },
        {
            "location": "/api/#skgardenquantilerandomforestquantileregressor",
            "text": "A random forest regressor that provides quantile estimates.  A random forest is a meta estimator that fits a number of classifying\ndecision trees on various sub-samples of the dataset and use averaging\nto improve the predictive accuracy and control over-fitting.\nThe sub-sample size is always the same as the original\ninput sample size but the samples are drawn with replacement if bootstrap=True  (default).  Parameters    n_estimators  (integer, optional (default=10))  The number of trees in the forest.    criterion  (string, optional (default=\"mse\"))  The function to measure the quality of a split. Supported criteria\nare \"mse\" for the mean squared error, which is equal to variance\nreduction as feature selection criterion, and \"mae\" for the mean\nabsolute error.\n.. versionadded:: 0.18\n   Mean Absolute Error (MAE) criterion.    max_features  (int, float, string or None, optional (default=\"auto\"))  The number of features to consider when looking for the best split:\n- If int, then consider  max_features  features at each split.\n- If float, then  max_features  is a percentage and\n   int(max_features * n_features)  features are considered at each\n  split.\n- If \"auto\", then  max_features=n_features .\n- If \"sqrt\", then  max_features=sqrt(n_features) .\n- If \"log2\", then  max_features=log2(n_features) .\n- If None, then  max_features=n_features .\nNote: the search for a split does not stop until at least one\nvalid partition of the node samples is found, even if it requires to\neffectively inspect more than  max_features  features.    max_depth  (integer or None, optional (default=None))  The maximum depth of the tree. If None, then nodes are expanded until\nall leaves are pure or until all leaves contain less than\nmin_samples_split samples.    min_samples_split  (int, float, optional (default=2))  The minimum number of samples required to split an internal node:\n- If int, then consider  min_samples_split  as the minimum number.\n- If float, then  min_samples_split  is a percentage and\n   ceil(min_samples_split * n_samples)  are the minimum\n  number of samples for each split.\n.. versionchanged:: 0.18\n   Added float values for percentages.    min_samples_leaf  (int, float, optional (default=1))  The minimum number of samples required to be at a leaf node:\n- If int, then consider  min_samples_leaf  as the minimum number.\n- If float, then  min_samples_leaf  is a percentage and\n   ceil(min_samples_leaf * n_samples)  are the minimum\n  number of samples for each node.\n.. versionchanged:: 0.18\n   Added float values for percentages.    min_weight_fraction_leaf  (float, optional (default=0.))  The minimum weighted fraction of the sum total of weights (of all\nthe input samples) required to be at a leaf node. Samples have\nequal weight when sample_weight is not provided.    max_leaf_nodes  (int or None, optional (default=None))  Grow trees with  max_leaf_nodes  in best-first fashion.\nBest nodes are defined as relative reduction in impurity.\nIf None then unlimited number of leaf nodes.    bootstrap  (boolean, optional (default=True))  Whether bootstrap samples are used when building trees.    oob_score  (bool, optional (default=False))  whether to use out-of-bag samples to estimate\nthe R^2 on unseen data.    n_jobs  (integer, optional (default=1))  The number of jobs to run in parallel for both  fit  and  predict .\nIf -1, then the number of jobs is set to the number of cores.    random_state  (int, RandomState instance or None, optional (default=None))  If int, random_state is the seed used by the random number generator;\nIf RandomState instance, random_state is the random number generator;\nIf None, the random number generator is the RandomState instance used\nby  np.random .    verbose  (int, optional (default=0))  Controls the verbosity of the tree building process.    warm_start  (bool, optional (default=False))  When set to  True , reuse the solution of the previous call to fit\nand add more estimators to the ensemble, otherwise, just fit a whole\nnew forest.    Attributes    estimators_  (list of DecisionTreeQuantileRegressor)  The collection of fitted sub-estimators.    feature_importances_  (array of shape = [n_features])  The feature importances (the higher, the more important the feature).    n_features_  (int)  The number of features when  fit  is performed.    n_outputs_  (int)  The number of outputs when  fit  is performed.    oob_score_  (float)  Score of the training dataset obtained using an out-of-bag estimate.    oob_prediction_  (array of shape = [n_samples])  Prediction computed with out-of-bag estimate on the training set.    y_train_  (array-like, shape=(n_samples,))  Cache the target values at fit time.    y_weights_  (array-like, shape=(n_estimators, n_samples))  y_weights_[i, j] is the weight given to sample  j` while\nestimator i`` is fit. If bootstrap is set to True, this\nreduces to a 2-D array of ones.    y_train_leaves_  (array-like, shape=(n_estimators, n_samples))  y_train_leaves_[i, j] provides the leaf node that y_train_[i]\nends up when estimator j is fit. If y_train_[i] is given\na weight of zero when estimator j is fit, then the value is -1.    References \n.. [1] Nicolai Meinshausen, Quantile Regression Forests\n    http://www.jmlr.org/papers/volume7/meinshausen06a/meinshausen06a.pdf",
            "title": "skgarden.quantile.RandomForestQuantileRegressor"
        },
        {
            "location": "/api/#methods_5",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api/#randomforestquantileregressorfitx-y",
            "text": "Build a forest from the training set (X, y).  Parameters    X  (array-like or sparse matrix, shape = [n_samples, n_features])  The training input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csc_matrix .    y  (array-like, shape = [n_samples] or [n_samples, n_outputs])  The target values (class labels) as integers or strings.    sample_weight  (array-like, shape = [n_samples] or None)  Sample weights. If None, then samples are equally weighted. Splits\nthat would create child nodes with net zero or negative weight are\nignored while searching for a split in each node. Splits are also\nignored if they would result in any single class carrying a\nnegative weight in either child node.    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    X_idx_sorted  (array-like, shape = [n_samples, n_features], optional)  The indexes of the sorted training input samples. If many tree\nare grown on the same dataset, this allows the ordering to be\ncached between trees. If None, the data will be sorted here.\nDon't use this parameter unless you know what to do.    Returns    self  (object)  Returns self.",
            "title": "RandomForestQuantileRegressor.fit(X, y)"
        },
        {
            "location": "/api/#randomforestquantileregressorpredictx-quantilenone",
            "text": "Predict regression value for X.  Parameters    X  (array-like or sparse matrix of shape = [n_samples, n_features])  The input samples. Internally, it will be converted to dtype=np.float32  and if a sparse matrix is provided\nto a sparse  csr_matrix .    quantile  (int, optional)  Value ranging from 0 to 100. By default, the mean is returned.    check_input  (boolean, (default=True))  Allow to bypass several input checking.\nDon't use this parameter unless you know what you do.    Returns    y  (array of shape = [n_samples])  If quantile is set to None, then return E(Y | X). Else return\ny such that F(Y=y | x) = quantile.",
            "title": "RandomForestQuantileRegressor.predict(X, quantile=None)"
        },
        {
            "location": "/api/#properties_5",
            "text": "",
            "title": "Properties"
        }
    ]
}